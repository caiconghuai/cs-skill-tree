---
layout: post
title: 七大查找算法 I
categories: algorithm
description:
keywords: 算法, 查找
---

# 前言

查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单的概括性的介绍常见的七种查找算法。这是第一部分，主要介绍顺序查找、折半查找、差值查找，分块查找。

- **查找的定义**

  - 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。

- **查找算法分类**

  - 静态查找和动态查找：
    - 静态或动态是针对查找表而言的，动态表指查找表中有删除或插入操作的表。
  - 无序查找和有序查找
    - 无序查找：被查找数列有序无序即可。
    - 有序查找：被查数列必须为有序数列。

- **平均查找长度**（Average Search Length, ASL）

  - 需和指定key进行比较的关键字的个数和期望值，称为查找算法在查找成功时的平均查找长度。
  - 对于含有n个数据元素的查找表，查找成功的平均查找长度为：

  ![](https://latex.codecogs.com/gif.latex?ASL%20%3D%20%5Csum_%7Bi%7D%5E%7Bn%7DP_i*C_i)

  - Pi 查找表中第i个数据元素的概率。
  - Ci 找到第i个数据元素时已经比较过的次数。

# 1. 顺序查找

## 1.1 说明

顺序查找适合于存储结构为顺序存储或链接存储的线性表。

## 1.2 基本思想

顺序查找的想法非常的简单，也称为线性查找，属于无序查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束扔没有找到关键字等于k的结点，表示查找失败。

## 1.3 代码实现

```c++
int SequenceSearch(int a[], int value, int n)
{
    int i;
    for(i=0; i<n; i++)
        if(a[i]==value)
            return i;
    return -1;
}
```

## 1.4 复杂度分析

- 对于n个元素的表，给定值key与表中第i个元素的关键字相等，即定位第i个元素时，需要进行n-i+1次关键字的比较，即Ci = n - i + 1, Pi = 1/n, 因此，顺序查找的平均长度为：

![](https://latex.codecogs.com/gif.latex?ASL%20%3D%20%5Csum_%7Bi%7D%5E%7Bn%7D%5Cfrac%7B1%7D%7Bn%7D*%28n-i&plus;1%29%20%3D%20%5Cfrac%7Bn&plus;1%7D%7B2%7D)

- 查找不成功时，与表中各关键字的比较次数显然是n+1次，从而顺序查找不成功的平均查找长度为ASL = n+1

## 1.5 应用场景

综合分析，顺序查找的缺点是当n较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键码有序均可应用。

# 2. 折半查找

## 2.1 说明

元素必须是有序的，如果是无序的则要先进行排序操作。

## 2.2 基本思想

属于有序查找算法，用给定值k先与中间结点的关键字比较，中间结点把线性表分成两个字表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

![](/images/posts/2017-10-08/1-1.png)

折半查找的过程，对应于一颗判定树：

![](/images/posts/2017-10-08/1-2.png)

## 2.3 代码实现

```c++
//二分查找（折半查找），while
int BinarySearch1(int a[], int value, int n)
{
    int low, high, mid;
    low = 0;
    high = n-1;
    while(low<=high)
    {
        mid = (low+high)/2;
        if(a[mid]==value)
            return mid;
        if(a[mid]>value)
            high = mid-1;
        if(a[mid]<value)
            low = mid+1;
    }
    return -1;
}

//二分查找，递归
int BinarySearch2(int a[], int value, int low, int high)
{
    int mid = low+(high-low)/2;
    if(a[mid]==value)
        return mid;
    if(a[mid]>value)
        return BinarySearch2(a, value, low, mid-1);
    if(a[mid]<value)
        return BinarySearch2(a, value, mid+1, high);
}
```
## 2.4 复杂度分析

最坏情况下，关键词比较次数为log2(n+1)，切期望时间复杂度为O(log2n)；

## 2.5 应用场景

折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

# 3. 差值查找

## 3.1  说明

在介绍差值查找之前，首先需要考虑一个问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。

经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中，查找点计算如下：

mid = (low+high) / 2 ，即 

mid = low + 1/2 * (high - low)

通过类比，我们可以将查找的点改进如下：

mid = low + (key - a[low]) / (a[high] - a[low]) * (high - low)

也就是讲上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接的减少了比较次数。

## 3.2 基本思想

基于二分查找算法思想，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。

## 3.3 代码实现

```c++
//插值查找
int InsertionSearch(int a[], int value, int low, int high)
{
    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);
    if(a[mid]==value)
        return mid;
    if(a[mid]>value)
        return InsertionSearch(a, value, low, mid-1);
    if(a[mid]<value)
        return InsertionSearch(a, value, mid+1, high);
}
```

## 3.4 复杂度分析

**查找成功或者失败的时间复杂度均为O(log2(log2n))。**

## 3.5 应用场景

对于表长较大，而关键字分布又比较均匀的查找表来说，差值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布非常不均匀，那么差值查找未必是很合适的选择。

# 4. 分块查找

## 4.1 说明

分块查找，又称为索引顺序查找，吸取了顺序查找和折半查找各自的特点，既有动态结构，又适于快速查找。

## 4.2 基本思想

分块查找的基本思想：讲查找表分为若干个子块。块内的元素可以无序，但块之间的是有序的，即第一块中的最大关键字小于第二块中的所有记录的关键字，第二块中的最大关键字小于第三块中的所有记录的关键字，依次类推 。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。

![](/images/posts/2017-10-08/1-3.png)

## 4.3 复杂度分析

ASL = LI + LS

时间复杂度的计算分为两部分，第一部分是找索引，由于索引表已经有序排列，所以这部分可以按照折半或者差值来索引，第二部分块内元素不一定是有序的，所以这一部分可以采用顺序查找。两部分时间复杂度的计算在上述已经讨论过。

# 5. 总结

这篇文章主要介绍了顺序查找、折半查找、差值查找和分块查找，其中顺序查找要求最低，但时间复杂度也是最高的，折半查找和差值查找需要在有序的数据集中进行，但同时时间复杂度也较低，对于变化不大的数据集，可以考虑先对数据集进行排序后再用折半查找和差值查找来做。分块查找是对顺序查找和折半查找的一个综合，通过建立索引，可以将时间复杂度分为两部分，找索引部分和块内找元素的部分，由于索引表默认是有序的，可以通过折半查找来查找索引。