# 包裹型

特征选择的过程为：首先从特征全集中产生出一个特征子集，然后用评价函数对该特征子集进行评价，评价的结果与停止准则进行比较，若评价结果比停止准则好就停止，否则就继续产生下一组特征子集，继续进行特征选择，选出来的特征子集一般还要验证其有效性。

产生过程是搜索特征子集的过程，负责为评价函数提供特征子集。搜索的算法分为完全搜索、启发式搜索、随机搜索三类：

![](https://pic002.cnblogs.com/images/2011/63234/2011090620164444.jpg)

### 完全搜索

完全搜索分为穷举搜索与非穷举搜索两类。

- **广度优先搜索**：广度优先遍历特征子空间，枚举了所有的特征组合，属于穷举搜索，时间复杂度是$O(2^n)$，实用性不高。
- **分支限界搜索：**在穷举搜索的基础上加入分支限界。
- **定向搜索**
- **最优优先搜索**

### 启发式搜索

- **序列前向选择（SFS，Sequential Forward Selection）：**特征子集X从空集开始，每次选择一个特征x加入特征子集X，使得特征函数$J(X)$最优。简单来说就是，每次都选择一个使得评价函数的取值达到最优的特征加入。缺点是只能加入特征而不能去除特征。例如：特征A完全依赖于特征B与C，可以认为如果加入了特征B与C则A就是多余的。假设序列前向选择算法首先将A加入特征集，然后又将B与C加入，那么特征子集中就包含了多余的特征A。
- **序列后向选择（SBS，Sequential Backward Selection）：**从特征全集$O$开始，每次从特征集$O$中剔除一个特征x，使得剔除特征x后评价函数值达到最优。序列后向选择与序列前向选择正好相反，它的缺点是特征只能去除不能加入。
- **双向搜索（BDS，Bidirectional Search）**：使用序列前向选择(SFS)从空集开始，同时使用序列后向选择(SBS)从全集开始搜索，当两者搜索到一个相同的特征子集C时停止搜索。
- **增L去R选择算法**：该算法有两种形式
  - 算法从空集开始，每轮先加入L个特征，然后从中去除R个特征，使得评价函数值最优。( L > R )
  - 算法从全集开始，每轮先去除R个特征，然后加入L个特征，使得评价函数值最优。( L < R )
- **序列浮动选择：**序列浮动选择由增L去R选择算法发展而来，该算法与增L去R选择算法的不同之处在于：序列浮动选择的L与R不是固定的，而是“浮动”的，也就是会变化的。
  - 序列浮动前向选择( SFFS , Sequential Floating Forward Selection )
  - 序列浮动后向选择( SFBS , Sequential Floating Backward Selection )
- **决策树（Decision Tree Method，DTM）**：在训练样本集上运行C4.5或其他决策树生成算法，待决策树充分生长后，再在树上运行剪枝算法，则最终决策树各分支处的特征就是选出来的特征子集了。

### 随机算法

- **随机产生序列选择算法（RGSS，Random Generation plus Sequential Selection）**：随机产生一个特征子集，然后在该子集上执行SFS与SBS算法。
- **模拟退火算法**
- **遗传算法**