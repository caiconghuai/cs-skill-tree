# 1. 并发基础

CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。	CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。

- 上下文切换需要时间和开销。
- 减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。

并发编程中有三个比较重要的概念：

- **原子性**：一个操作或者多个操作，要么都成功；要么都失败，中间不能由于任何的因素取消。
- **可见性**：使用volatile关键字保证可见性。
- **有序性**
  - 代码的执行顺序，编写在前面的发生在编写在后面的
  - unlock必须发生在lock之后
  - volatile修饰的变量，对变量的写操作先于该变量的读操作
  - 传递规则，操作A先于B，B先于C，那么A肯定先于C
  - 线程启动规则，start方法肯定先于线程run
  - 线程中断规则，interrupt这个动作，必须发生在捕获该动作之前
  - 对象销毁规则，初始化必须发生在finalize之前
  - 线程终结规则，所有的操作都发生在线程死亡之前

### Thread

- Thread是线程对象，用来创建和开始一个线程。

- Thread().start()方法用来启动线程，里面会执行Runnable对象的run()方法，这是采用的是策略设计模式。

- start0()是native方法，用c++写的，与底层交互。

- Thread的命名规则：创建线程对象，默认有一个线程名，从Thread-0开始一次加1。

- 如果在构造Thread的时候，没有传递Runnable或者没有复写，则该方法不会调用任何东西。

- 如果构造线程对象时，未传入ThreadGroup，此时会用父线程的ThreadGroup。

- 构造Thread的时候传入stacksize代表着该线程占用的stack大小，如果没有指定stacksize的大小，默认是0, 0代表着会忽略该参数，该参数会被JNI函数去使用。注意：该参数在一些平台有效，在一些平台无效。

- 可以通过ThreadFactory的工厂类来创建线程对象。

- | name         |
  | ------------ |
  | priority     |
  | group        |
  | tid          |
  | threadStatus |

### Runnable

- Runnable是给线程执行的对象，必须重写run方法，该方法供对象调用。

### Resource

- 如果资源在多个线程内部，那么多线程不能一起协作，完成系统的任务。
- 让多线程共享资源的方法：
  - 将资源声明为static
  - 将要执行的业务逻辑封装成一个Runnable对象，那么这些资源在Runnable对象中，不同线程执行该Runnable对象都可以访问该资源。
- 我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能改看到发生的状态变化。

# 2. 线程安全

- 安全性的含义是，永远不发生糟糕的事情，当多个线程访问某个类时，这个类始终都能表现出正确的行为。
- 核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。对象的状态指存储在状态变量中的数据。
- 修复多个线程访问同一个可变的状态变量，不使用同步的方法：
  - 不在线程之间共享该状态变量
  - 将状态遍历修改为不可变的变量

### 无状态性

- 不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。多个线程之间没有共享状态。
- 无状态对象一定是线程安全的。

### 竞态条件

- 由于多线程共享相同的内存地址空间，并且是并发运行的，因此它们可能会访问或修改其他线程正在使用的变量。
- 当某个计算正确性取决于多个线程的交替执行时序时，就会发生竟态条件。观察结果的失效性是大多数竟态条件的本质-**基于一种可能失效的观察结果来做出判断或者执行某个计算**。
- 常见的竟态条件
  - **先检查后执行**
    - 延迟初始化

### 原子操作及方法

原子操作是指，对于访问同一个状态的所有操作来说，这个操作是一个以原子方式执行的操作。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

每个Java对象都可以被用做一个实现同步的锁，这些锁被称为内置锁或监视锁。线程在进入同步代码块之前会自动获得锁，并且在退出后自动释放锁。

Java的内置锁相当于一个互斥体，这意味着最多只有一个线程能持有这种锁。这个锁保护的同步代码块会以原子方式执行。

每个共享的和可变的变量都应该只由一个锁来保护。

对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，是为了确保某个线程写入该变量的值对于其他线程来说是可见的。

加锁的含义不仅仅局限于互斥行为，还包括**内存可见性**，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

- **同步锁**
  - **Synchronized**：使得共享资源在多个线程之间访问时采用了同步的方式，避免线程之间的安全问题。
    - 直接使用synchronized给对象和方法加锁，默认使用的**this**这把锁。同一时刻只有一个执行线程被允许访问，其他线程如果试图访问这个对象的其他方法，都会被挂起。
    - 如果给静态的方法加锁，那么此时使用的是类名.class 这把锁。对静态方法加锁，同时只能够被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。
    - Java中的每一个对象都可以作为锁。
      - 对于普通同步方法，锁是当前实例对象。
      - 对于静态同步方法，锁是当前类的Class对象。
      - 对于同步方法块，锁是synchonized括号里配置的对象。
  - **Lock**： Lock是一种比synchonized关键字更强大也更灵活的机制。
    - 支持更灵活的同步代码块结构。
    - 提供**tryLock()**方法的实现。这个方法试图获取锁，如果锁已被其他线程获取，他将返回false并继续往下执行代码。
    - **Lock**允许分离读和写操作，允许多个读线程和一个写线程。
    - **Condition：**
      - 一个锁可能关联一个或者多个条件，这些条件通过**Condition**接口声明，目的是允许线程获取锁并且查看等待的某一个条件是否满足。如果不满足就挂起直到某个线程唤醒它们。
      - 与锁绑定的所有条件对象都是通过**Lock**接口声明的**newCondition**()方法创建的，在使用条件的时候，必须获取这个条件绑定的锁。所以带条件的代码必须在调用Lock对象的lock()和unlock()方法之间。
      - 当线程调用条件**await**()方法时，它将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。
      - **awaitUninterruptibly**()是不可中断的，这个线程将休眠直到其他某个线程调用了将它挂起的条件的**signal**()或**signalAll**()方法。
    - **WaitSet**
- **线程封闭**：
  - 仅在单线程内访问数据，不共享数据。
  - 栈封闭是线程封闭的一种特例，局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。
  - 维持线程封闭性的一种更规范方法是使用**ThreadLocal**, 这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本， 因此get总是返回由当前执行线程在调用set时设置的最新值。
    - 当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。
    - 从概念上来讲，可以将`ThreadLocal<T>`视为包含了`Map<Thread,T>`对象，其中保存了特定于该线程的值。
    - ThreadLocalRandom是线程本地变量，每个生成随机数的线程都有一个不同的生成器。但都在同一个类中被管理，对于程序员来说时透明的。
    - 相比于使用共享的Random对象为所有线程生成随机数，这种机制具有更好的性能。
- **线程安全对象**
  - 应尽可能的使用现有的线程安全对象（如ActomicLong）来管理类的状态，与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证安全性。
  - **Atomic Variable**
    - 原子变量是从Java5开始引入的，它提供了单个变量上的原子操作。
    - 一般来说，这种操作先获取变量值，然后在本地改变变量的值，然后试图用这个改变的值去替换之前的值。如果之前的值没有被其他线程改变，就可以执行这个替换操作。否则，方法将再执行这个操作。这种操作称为**CAS**原子操作。
    - 采用比较和交换机制不需要使用同步机制，不仅可以避免死锁，而且性能更好。
    - 在Java中可以通过**锁**和**循环CAS**的方式来实现原子操作。存在的问题：
      - **ABA**问题 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化。那么解决该问题的方法是使用版本号，每次变量更新的时候把版本号加1。JDK提供了一个类AtomicStampedReference来解决ABA问题。
      - 循环时间开销大。
      - 只能保证一个共享变量的原子操作。
  - **不可变对象：**
    - 如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。
    - 不可变对象一定是线程安全的。
    - 除非需要某个域是可变的，否则将其声明为final域，是一个良好的编程习惯。
    - 满足不可变对象的条件：
      - 对象创建以后其状态就不能修改。
      - 对象的所有域都是final类型。
      - 对象是正确创建的。
- **volatile**：Java编程语言允许线程访问共享变量，为了确保变量能够准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。将当前处理器缓存行的数据协会到系统内存。这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
  - volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
  - 在访问volatile变量时不会执行加锁操作，但是我们可以把它的行为想成加锁的get和set方法。
  - 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
  - 使用条件：
    - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新遍历的值
    - 该变量不会与其他状态变量一起纳入不变性条件中。
    - 在访问变量时不需要加锁。
  - 典型用法：
    - 检查某个状态标记以判断是否退出循环。

# 3. 并发数据结构

Java提供了一些可以用于并发程序中的数据结合，分阻塞式和非阻塞式的。

### ConcurrentHashMap

ConcurrentHashMap也是基于散列的Map，但它使用了不同的加锁策略来提供更高的并发性和伸缩性。采用了一种粒度更细的加锁机制来实现更大程度的共享，称为分段锁。

### CopyOnWriteArrayList

在迭代期间不需要对容器进行加锁或复制。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

仅当迭代操作远远多于修改操作时，才应该使用写入时复制。

### BlockingQueue

BlockingQueue简化了生产者-消费者设计的实现过程，它支持任意数量的生产者和消费者。

一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在Executor任务执行框架中就体现这种模式。

- LinkedBlockingQueue
- ArrayBlockingQueue
- SynchronousQueue
- Deque
- ConcurrentLinkedDeque
- LinkedBlockingDeque
- PriorityBlockingQueue
- DelayQueue
- ConcurrentSkipListMap

# 4. 线程通信

我们希望多个线程之间能够相互之间交换信息，从而能够更好的协作，完成任务。线程之间通过wait notify方法进行通信。同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流，阻塞队列可以作为同步工具类，其他类型的同步工具类包括**信号量**、**栅栏**、以及**闭锁**。

线程之间的通信机制有两种：共享内存和消息传递。

- 共享内存，线程之间共享程序的公共状态，通过写-读内存中的公共状态来隐式通信。
- 消息传递，线程之间必须通过发送消息来显式通信。

### Interrupt wait notify

- Thread提供了**interrupt**方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态。
- 中断是一种协作机制。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作-**前提是如果线程B愿意停止下来**。
- 调用interrupt并不意味着立即停止目标线程正在进行的工作，而是传递了请求中断的消息。
- 由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。
- 所有的对象都会有一个wait set， 用来存放调用了该对象wait方法之后进入block状态线程。
- 线程从wait set中被唤醒顺序不一定是FIFO。
- wait方法会释放锁对象，当被唤醒之后需要再去请求锁对象，得到锁对象之后，代码会从wait的地方开始往下执行。

### Latch

闭锁是一种不同工具类，可以延迟线程的进度直到其到达终止状态。闭锁相当于一扇门，在闭锁到达结束状态之前，这扇门一直是关闭的。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。

- **CountDownLatch**
  - CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况使用，它可以是一个或多个线程等待一组事件发生。
  - 这个类使用一个**整数**进行初始化，这个整数就是线程要等待完成的操作的数目。当一个线程要等待某些操作先执行完时，需要调用await()方法，这个方法让线程进入休眠直到等待的所有操作都完成，当某个操作完成后，它将调用countDown()方法将CountDownLatch类的内部计数器减1,，当计数器变为0的时候，CountDownLatch将唤醒所有调用await()方法而进入休眠的线程。
  - CountDownLatch类有三个基本元素：
    - 一个初始值，即定义必须等待的先行完成的操作的数目。
    - await()方法
    - countDown()方法，每个被等待的事件在完成的时候调用。
  - CountDownLatch机制
    - CountDownLatch机制不是用来保护共享资源或者临界区的，它是用来同步执行多个任务的一个或者多个线程；
    - CountDownLatch只准许进入一次。



### Counting Semaphore

计算信号量用来控制同时访问某个特定资源的操作数量，或者执行某个指定操作的数量。

Semaphore中管理着一组虚拟的许可，许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可，并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可。release方法将返回一个许可给信号量。

Semaphore可以用来实现资源池。

### Barrier

栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏和闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。

- **CyclicBarrier**
  - CyclicBarrier可以使一定数量的参与方反复的在栅栏位置汇集。
  - CyclicBarrier类使用一个整型数进行初始化，这个数是需要在某个点上同步的线程数。
  - 当一个线程到达的指定的点后，它将调用await()方法等待其他的线程，当线程调用await()方法后，CyclicBarrier类将阻塞这个线程并使之休眠直到所有其他线程到达。当最后一个线程调用CyclicBarrier类的await()方法时，CyclicBarrier对象将唤醒所有在等待的线程，然后这些线程将继续执行。
  - CyclicBarrier类有一个很有意义的改进，即它可以传入另一个Runnable对象作为初始化参数。当所有的线程都到达集合点后，CyclicBarrier类将这个Runnable对象作为线程执行。

### **Phaser**

允许执行并发多阶段任务。当我们有并发任务并且需要分解成几步执行时，这种机制就非常适用。Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才允许执行下一步。

### Exchanger

Exchanger允许在并发任务之间交换数据。Exchanger类允许在两个线程之间定义同步点，当两个线程都到达同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程中。

# 5. 并发编程框架

### Executor框架

任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。串行执行的问题在于其糟糕的响应性和吞吐量，而“为每个任务分配一个线程”的问题在于资源管理的复杂性。

通过使用Executor，可以实现各种調优、管理、监视、记录日志、错误报告和其他功能，如果不使用任务执行框架，那么要增加这些功能非常困难。

当运行大量的并发任务，手动创建Runnable对象和Thread对象来执行它们有如下缺点:

- 必须实现所有与Thread对象管理相关的代码，比如线程的创建、结束以及结果获取。

执行器的另一个优势是Callable接口，这个接口的主方法名称为call()，可以返回结果。当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象，可以使用这个对象控制Callable对象的状态和结果。

执行器框架(Executor Framework)将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable接口的对象和使用Executor对象，然后将Runnable对象发送给执行器。执行器再负责运行这些任务所需要的线程，包括线程的创建，线程的管理以及线程的结束。

它提供了一种标准的方法将任务的提交过程与执行过程解偶开来，并用Runnable来表示任务。

Executor的实现还提供了生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。

Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。

### ExecutorService

- 为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命管理的方法。
- 在ExecutorService关闭后提交的任务将由“拒绝执行处理器”来处理，它会抛弃任务，或者使得execute方法将转入终止状态。

### ThreadPool

- 线程池，是指管理一组同构工作线程的资源池。
- 在线程池中执行任务比为每个任务分配一个线程优势更多，通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。
- 可以通过调用Executors中的静态工厂方法之一来创建一个线程池。
- 当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。
  - **AbortPolicy**：中止策略，是默认的饱和策略，该策略抛出未经检查的RejectedExecutionException。
  - **CallerRunsPolicy**：调用者策略，实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
- 每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时，都会调用这个方法。

|              方法               |                    作用                    |
| :---------------------------: | :--------------------------------------: |
|      newFixedThreadPool       | 创建一个固定长度的线程池；<br />在默认情况下将使用一个无界的LinkedBlockingQueue。 |
|      newCachedThreadPool      | 1. 创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。<br />2. 对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队。<br />3. 只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。 |
|    newSingleThreadExecutor    | 1. 是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能确保依照任务在队列中的顺序来串行执行。<br /> |
|    newScheduledThreadPool     | 1. 创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br />2.为了在定时执行器中等待一段给定的时间后执行一个任务，需要使用schedule()方法。 |
| Customized ThreadPoolExecutor | 1. Java并发API提供了大量接口和类来实现并发应用程序，这些接口和类既包含底层机制，如Thread类，Runnable接口或Callable接口，synchronized关键字，也包含了高层机制，如Executor框架，尽管如此，开发应用中，仍会发现已有的Java类无法满足需求。<br />2. 步骤：<br />2.1 实现一个接口以拥有接口定义的功能，如 ThreadFactory接口。<br />2.2 覆盖类的一些方法，改变这些方法的行为，来满足需求，例如，覆盖Thread类的run()方法。<br />3. 任务：<br />3.1 通过Runnable接口实现的任务，不返回结果。<br />3.2 通过Callable接口实现的任务，它返回结果。 |

### Callable

- Callable这个接口声明了call()方法，可以在这个方法里实现任务的具体逻辑操作。Callable接口时一个泛型接口，这就意味着必须声明call()方法返回的数据类型。
- Future这个接口声明了一些方法来获取由Callabel对象产生的结果，并管理它们的状态。

### ThreadFactory

工厂模式在面向对象编程中是一个应用广泛的设计模式，它是一种创建模式。