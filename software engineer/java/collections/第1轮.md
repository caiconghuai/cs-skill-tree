# Collections

## 1. 将Map转化为List

在Java中，Map接口提供了三种集合视图，分别是:

- key set
- value set
- key-value set

这三种视图都可以通过构造器或者`addAll()`方法转化为List。

```java
// key list
List keyList = new ArrayList(map.keySet());
// value list
List valueList = new ArrayList(map.values());
// key-value list
List entryList = new ArrayList(map.entrySet());
```

## 2. 如何遍历一个Map

遍历Map，实际上就是要遍历Map中的每个键值对，在Java中，这个键值对被抽象成map entry，即`Map.Entry`对象。可以通过`Map.entrySet()`方法来返回这些key-value对集合。

```java
for(Entry entry: map.entrySet()) {
// get key
K key = entry.getKey();
// get value
V value = entry.getValue();
}

// Iterator can also be used, especially before JDK 1.5
Iterator itr = map.entrySet().iterator();
while(itr.hasNext()) {
Entry entry = itr.next();
// get key
K key = entry.getKey();
// get value
V value = entry.getValue();
}
```

## 3. 根据Key的值对Map排序

根据Map中Key的值对Map键值对进行排序，也是一个常见的问题，有两种方案可以解决该问题：

- 将Map.Entry放到一个List中，然后通过比较器对List进行比较

```java
List list = new ArrayList(map.entrySet());
Collections.sort(list, new Comparator() {
  @Override
  public int compare(Entry e1, Entry e2) {
     return e1.getKey().compareTo(e2.getKey());
  }
});
```

- 另一种是先构造出一个SortedMap，然后将该map添加到这个有序的Map中。

```java
SortedMap sortedMap = new TreeMap(new Comparator() {
 
  @Override
  public int compare(K k1, K k2) {
    return k1.compareTo(k2);
  }
 
});
sortedMap.putAll(map);
```

## 4. 根据Values值对Map进行排序

根据Map中的值对Map键值对进行排序，也是一个常见的问题，可以借鉴上面的方案，先将entrySet()放入List中，然后通过比较器对其进行比较:

```java
List list = new ArrayList(map.entrySet());
Collections.sort(list, new Comparator() {
 
  @Override
  public int compare(Entry e1, Entry e2) {
    return e1.getValue().compareTo(e2.getValue());
  }
 
});
```

## 5. 构建一个不可变的Map

如果你想要Map保存不可变，你需要借助`Collections.unmodifiableMap(map)`方法，将你想要保存为不可变的map传递给该方法。此外，还需要用`static final`来修饰该map。

```java
public class Test {
 
  private static final Map map;
  static {
    Map aMap = new HashMap();
    aMap.put(1, "one");
    aMap.put(2, "two");
    map = Collections.unmodifiableMap(aMap);
  }
}
```

如果你只是用`static final`来修饰该map，我们仍可以调用`map.put(x,y)`往map中放入键值对。

## 6. HashMap, TreeMap, Hashtable的区别

`Map`接口下主要有三种实现，分别是: `HashMap`、`TreeMap`和`Hashtable`，它们三者主要的区别在于:

- **迭代的顺序**: `HashMap`和`Hashtable`不能保证map中键值对的顺序。而`TreeMap`可以保证用自然顺序或者比较器指定的顺序来迭代键值对。
- **是否允许空值**:
  - `HashMap`允许 null key 和 null values，但是只能有一个null key存在，不能有两个，否则出现key相同的情况。
  - `Hashtable`不允许有null key 和 null values
  - `TreeMap`如果其自然顺序或者比较器不允许 null key，那么将会抛出异常。
- **并发安全:**
  - 只有`Hashtable`才是并发安全的，其他不是并发安全的，如果程序没有多线程并发问题，建议使用`HashMap`，因为其性能优于`Hashtable`。

|                  | HashMap | Hashtable |    TreeMap     |
| ---------------- | :-----: | :-------: | :------------: |
| interation order |   no    |    no     |      yes       |
| null key-value   | yes-yes |   no-no   |     no-yes     |
| synchronized     |   no    |    yes    |       no       |
| time performance |  O(1)   |   O(1)    |    O(log n)    |
| implementation   | buckets |  buckets  | red-black tree |

## 7. 双向Map

如果我们需要通过value来寻找key，当然，此时需要保证key-value是一一对应的关系，这种Map有时候也称为`bidirectioanl map`，但是Java并没有提供对这种数据结构的支持。

可以借助Apache Common Collections下的BidiMap对象完成上述操作。

## 8. 浅拷贝Map

大部分的Map实现中，都提供了通过构造器浅复制其他map。但是该过程不是并发安全的，这意味着，如果一个线程正在复制该map，另一个线程同时修改该map，那么将导致并发问题。一种改进方案就是通过`Collections.synchronizedMap()`进行浅拷贝。

另一种方案是通过`clone()`方法进行拷贝，但是，就连Java集合框架的设计者都不建议使用`clone()`方法进行拷贝，他说道:

> I often provide a public clone method on concrete classes because people expect it. ... It's a shame that Cloneable is broken, but it happens. ... Cloneable is a weak spot, and I think people should be aware of its limitations.

因此，并不建议使用`clone()`方法对map进行拷贝。

## 9. 创建一个空Map

如果要求Map是不可变的:

```java
map = Collections.emptyMap();
```

否则的话，创建任何一种实现即可:

```java
map = new HashMap();
```

## 10. Java Remove Element from ArrayList

To remove some elements from an ArrayList while iterating over the ArrayList, we need to use Iterator.

```java
Integer[] arr = {1,2,3,4,5,6};
ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(arr));
System.out.println(list);
 
Iterator<Integer> iter = list.iterator();
while(iter.hasNext()){
	int i = iter.next();
	if(i==5)
		iter.remove();
}
 
System.out.println(list);
```

If the element is removed by using ArrayList.remove(i) method during iteration like the following, the program will throw a ConcurrentModificationException.

```
java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(Unknown Source)
	at java.util.ArrayList$Itr.next(Unknown Source)

```

## 11. Deep Understanding of ArrayList.iterator()

`iterator` often cause problems, because developers often do not know how it works. The following code is from source code of `ArrayList`.

One common problem is throwing [java.util.ConcurrentModificationException](https://www.programcreek.com/2014/01/java-util-concurrentmodificationexception/). This exception is actually throw in the `remove` method. `remove()` has to be called after `next()`. if `remove()` is called before `next()`, the size of arraylist changes, `modCount != expectedModCount` is satisfied, and ConcurrentModificationException is thrown.

```java
...
 
public Iterator<E> iterator() {
    return new Itr();
}
 
/**
 * An optimized version of AbstractList.Itr
 */
private class Itr implements Iterator<E> {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;
 
    public boolean hasNext() {
        return cursor != size;
    }
 
    @SuppressWarnings("unchecked")
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }
 
    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();
 
        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
 
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
 
...
```

## 12. java.util.ConcurrentModificationException

This post shows show to solve the problem of `java.util.ConcurrentModificationException` for `ArrayList`.

The error message looks like the following:

**The Problem**

You may want to iterate through an `ArrayList`, and delete some element under some condition. For example, the following code looks reasonable:

```java
import java.util.ArrayList;
import java.util.List;
 
public class AddRemoveListElement {
 
	public static void main(String args[]) {
		List<String> list = new ArrayList<String>();
		list.add("A");
		list.add("B");
 
		for (String s : list) {
			if (s.equals("B")) {
				list.remove(s);
			}
		}
	}
}
```

Output:

![](https://www.programcreek.com/wp-content/uploads/2014/01/java-util-concurrentModificationException.jpg)

**Solution 1**

`Iterator` can be used to solve this problem. `Iterators` allow the caller to remove elements from the underlying collection during the iteration.

```java
Iterator<String> iter = list.iterator();
while(iter.hasNext()){
	String str = iter.next();
      if( str.equals("B") )
      {
        iter.remove();
      }
}
```

**Solution 2**

Instead of `ArrayList`, `CopyOnWriteArrayList` can be used to solve the problem. `CopyOnWriteArrayList` is a thread-safe variant of `ArrayList` in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.

```Java
public static void main(String args[]) {
	List<String> list = new CopyOnWriteArrayList<String>();
	list.add("A");
	list.add("B");
 
	for (String s : list) {
		if (s.equals("B")) {
			list.remove(s);
		}
	}
}
```

**How about other Collection types?**

```java
public static void main(String args[]) {
	Set<String> set = new HashSet<String>();
	set.add("A");
	set.add("B");
 
	for (String s : set) {
		if (s.equals("B")) {
			set.remove(s);
		}
	}
}
```

```java
public static void main(String args[]) {
	LinkedList<String> llist = new LinkedList<String>();
	llist.add("A");
	llist.add("B");
 
	for (String s : llist) {
		if (s.equals("B")) {
			llist.remove(s);
		}
	}
}
```

The above code is fine, because they do not use array as the underlining data structure.

## 13. [Set vs. Set](https://www.programcreek.com/2013/12/raw-type-set-vs-unbounded-wildcard-set/)

You may know that an unbounded wildcard Set<?> can hold elements of any type, and a raw type Set can also hold elements of any type. What is the difference between them?

**1. Two facts about Set<?>**

There are two facts about Set<?>:

*Item 1: Since the question mark ? stands for any type. Set<?> is capable of holding any type of elements. *
*Item 2: Because we don't know the type of ?, we can't put any element into Set<?>*

So a Set<?> can hold any type of element(Item 1), but we can't put any element into it(Item 2). Do the two statements conflict to each other? Of course they are not. This can be clearly illustrated by the following two examples:

Item 1 means the following situation:

```java
//Legal Code
public static void main(String[] args) {
	HashSet<Integer> s1 = new HashSet<Integer>(Arrays.asList(1, 2, 3));
	printSet(s1);
 
	HashSet<String> s2 = new HashSet<String>(Arrays.asList("a", "b", "c"));
	printSet(s2);
}
 
public static void printSet(Set<?> s) {
	for (Object o : s) {
		System.out.println(o);
	}
}
```

Since Set<?> can hold any type of elements, we simply use Object in the loop.

Item 2 means the following situation which is illegal:

```java
//Illegal Code
public static void printSet(Set<?> s) {
	s.add(10);//this line is illegal 
	for (Object o : s) {
		System.out.println(o);
	}
}
```

Because we don't know the type of <?> exactly, we can not add any thing to it other than null. For the same reason, we can not initialize a set with Set<?>. The following is illegal:

```java
//Illegal Code
Set<?> set = new HashSet<?>();
```

**2. Set vs. Set<?>**

What's the difference between raw type Set and unbounded wildcard Set<?>?

This method declaration is fine:

```java
public static void printSet(Set s) {
	s.add("2");
	for (Object o : s) {
		System.out.println(o);
	}
}
```

**3. When Set<?> is useful?**

When you want to use a generic type, but you don't know or care what the actual type the parameter is, you can use <?>[1]. It can only be used as parameters for a method.

For example:

```java
public static void main(String[] args) {
	HashSet<Integer> s1 = new HashSet<Integer>(Arrays.asList(1,2,3));
	HashSet<Integer> s2 = new HashSet<Integer>(Arrays.asList(4,2,3));
 
	System.out.println(getUnion(s1, s2));
}
 
public static int getUnion(Set<?> s1, Set<?> s2){
	int count = s1.size();
	for(Object o : s2){
		if(!s1.contains(o)){
			count++;
		}
	}
	return count;
}
```

## 14. [Efficient Counter in Java](https://www.programcreek.com/2013/10/efficient-counter-in-java/)

You may often need a counter to understand the frequency of something (e.g., words) from a database or text file. A counter can be easily implemented by using a HashMap in Java. This article compares different approaches to implement a counter. Finally, an efficient one will be concluded.

UPDATE: Check out [Java 8 counter](https://www.programcreek.com/2014/01/java-8-counter/), writing a counter is just 2 simple lines now.

**1. The Naive Counter**

Naively, it can be implemented as the following:

```java
String s = "one two three two three three";
String[] sArr = s.split(" ");
 
//naive approach	 
HashMap<String, Integer> counter = new HashMap<String, Integer>();
 
for (String a : sArr) {
	if (counter.containsKey(a)) {
		int oldValue = counter.get(a);
		counter.put(a, oldValue + 1);
	} else {
		counter.put(a, 1);
	}
}
```

In each loop, you check if the key exists or not. If it does, increment the old value by 1, if not, set it to 1. This approach is simple and straightforward, but it is not the most efficient approach. This method is considered less efficient for the following reasons:

- containsKey(), get() are called twice when a key already exists. That means searching the map twice.
- Since Integer is immutable, each loop will create a new one for increment the old value

**2. The Better Counter**

Naturally we want a mutable integer to avoid creating many Integer objects. A mutable integer class can be defined as follows:

```java
class MutableInteger {
 
	private int val;
 
	public MutableInteger(int val) {
		this.val = val;
	}
 
	public int get() {
		return val;
	}
 
	public void set(int val) {
		this.val = val;
	}
 
	//used to print value convinently
	public String toString(){
		return Integer.toString(val);
	}
}
```

And the counter is improved and changed to the following:

```java
HashMap<String, MutableInteger> newCounter = new HashMap<String, MutableInteger>();	
 
for (String a : sArr) {
	if (newCounter.containsKey(a)) {
		MutableInteger oldValue = newCounter.get(a);
		oldValue.set(oldValue.get() + 1);
	} else {
		newCounter.put(a, new MutableInteger(1));
	}
}
```

This seems better because it does not require creating many Integer objects any longer. However, the search is still twice in each loop if a key exists.

**3. The Efficient Counter**

The HashMap.put(key, value) method returns the key's current value. This is useful, because we can use the reference of the old value to update the value without searching one more time!

```java
HashMap<String, MutableInteger> efficientCounter = new HashMap<String, MutableInteger>();
 
for (String a : sArr) {
	MutableInteger initValue = new MutableInteger(1);
	MutableInteger oldValue = efficientCounter.put(a, initValue);
 
	if(oldValue != null){
		initValue.set(oldValue.get() + 1);
	}
}
```

**4. Performance Difference**

To test the performance of the three different approaches, the following code is used. The performance test is on 1 million times. The raw results are as follows:

```
Naive Approach :  222796000
Better Approach:  117283000
Efficient Approach:  96374000
```

The difference is significant - 223 vs. 117 vs. 96. There is huge difference between *Naive* and *Better*, which indicates that creating objects are expensive!

![](https://www.programcreek.com/wp-content/uploads/2013/10/efficient-counter.png)

## 15. **When to use LinkedList over ArrayList?**

[ArrayList](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) is essentially an array. Its elements can be accessed directly by index. But if the array is full, a new larger array is needed to allocate and moving all elements to the new array will take *O(n)* time. Also adding or removing an element needs to move existing elements in an array. This might be the most disadvantage to use ArrayList.

[LinkedList](http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html) is a double linked list. Therefore, to access an element in the middle, it has to search from the beginning of the list. On the other hand, adding and removing an element in LinkedList is quicklier, because it only changes the list locally.

In summary, the **worst** case of time complexity comparison is as follows:

```
                   | Arraylist | LinkedList
 ------------------------------------------
 get(index)        |    O(1)   |   O(n)
 add(E)            |    O(n)   |   O(1)
 add(E, index)     |    O(n)   |   O(n)
 remove(index)     |    O(n)   |   O(n)
 Iterator.remove() |    O(n)   |   O(1)
 Iterator.add(E)   |    O(n)   |   O(1)
```

Despite the running time, memory usage should be considered too especially for large lists. In **LinkedList**, every node needs at least two extra pointers to link the previous and next nodes; while in **ArrayList**, only an array of elements is needed.

## 16. **Efficient equivalent for removing elements while iterating the Collection**

The only correct way to modify a collection while iterating is using [**Iterator**.*remove()*](http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html). For example,

```java
Iterator<Integer> itr = list.iterator();
while(itr.hasNext()) {
	// do something
	itr.remove();
}
```

One most frequent **incorrect** code is

```java
for(Integer i: list) {
  list.remove(i);
}
```

You will get a **ConcurrentModificationException** by running the above code. This is because an iterator has been generated (in **for** statement) to traverse over the list, but at the same time the list is changed by **Iterator**.*remove()*. In Java, "it is not generally permissible for one thread to modify a collection while another thread is iterating over it."

## 17. **How to convert List to int[]?**

The easiest way might be using **ArrayUtils** in [Apache Commons Lang](https://commons.apache.org/lang) library.

```java
int[] array = ArrayUtils.toPrimitive(list.toArray(new Integer[0]));
```

In JDK, there is no short-cut. Note that you can not use **List**.*toArray()*, because that will convert **List** to **Integer[]**. The correct way is following,

```java
int[] array = new int[list.size()];
for(int i=0; i < list.size(); i++) {
  array[i] = list.get(i);
}
```

## 18. **How to convert int[] into List?**

The easiest way might **still** be using **ArrayUtils** in [Apache Commons Lang](https://commons.apache.org/lang) library, like below.

```java
List list = Arrays.asList(ArrayUtils.toObject(array));
```

In JDK, there is no short-cut either.

```java
int[] array = {1,2,3,4,5};
List<Integer> list = new ArrayList<Integer>();
for(int i: array) {
  list.add(i);
}
```

## 19. **What is the best way to filter a Collection?**

Again, you can use third-party package, like [Guava](https://code.google.com/p/guava-libraries/) or [Apache Commons Lang](https://commons.apache.org/lang) to fullfil this function. Both provide a *filter()* method (in **Collections2** of Guava and in **CollectionUtils** of Apache). The *filter()* method will return elements that match a given **Predicate**.

In JDK, things become harder. A good news is that in Java 8, **Predicate** will be added. But for now you have to use **Iterator** to traverse the whole collection.

```java
Iterator<Integer> itr = list.iterator();
while(itr.hasNext()) {
   int i = itr.next();
   if (i > 5) { // filter all ints bigger than 5
      itr.remove();
   }
}
```

Of course you can mimic the way of what Guava and Apache did, by introducing a new interface **Predicate**. That might also be what most advanced developers will do.

```java
public interface Predicate<T> {
   boolean test(T o);
}
 
public static <T> void filter(Collection<T> collection, Predicate<T> predicate) {
    if ((collection != null) && (predicate != null)) {
       Iterator<T> itr = collection.iterator();
          while(itr.hasNext()) {
            T obj = itr.next();
            if (!predicate.test(obj)) {
               itr.remove();
            }
        }
    }
}
```

Then we can use the following code to filter a collection:

```java
filter(list, new Predicate<Integer>() {
    public boolean test(Integer i) { 
       return i <= 5; 
    }
});
```

## 20. **Easiest way to convert a List to a Set?**

There are two ways to do so, depending on how you want *equal* defined. The first piece of code puts a list into a **HashSet**. Duplication is then identified mostly by *hashCode()*. In most cases, it will work. But if you need to specify the way of comparison, it is better to use the second piece of code where you can define your own comparator.

```java
Set<Integer> set = new HashSet<Integer>(list);
```

```java
Set<Integer> set = new TreeSet<Integer>(aComparator);
set.addAll(list);
```

## 21. **How do I remove repeated elements from ArrayList?**

This question is quite related to the above one.
If you don't care the ordering of the elements in the **ArrayList**, a clever way is to put the list into a set to remove duplication, and then to move it back to the list. Here is the code

```java
ArrayList** list = ... // initial a list with duplicate elements
Set<Integer> set = new HashSet<Integer>(list);
list.clear();
list.addAll(set);
```

If you DO care about the ordering, order can be preserved by putting a list into a LinkedHashSet which is in the standard JDK﻿.﻿

## 22. **Sorted collection** 

There are a couple of ways to maintain a sorted collection in Java. All of them provide a collection in natural ordering or by the specified comparator. By *natural ordering*, you also need to implement the **Comparable**interface in the elements.

1. [**Collections**.*sort()*](http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#sort(java.util.List)) can sort a **List**. As specified in the javadoc, this sort is *stable*, and guarantee *n log(n)*performance.
2. **PriorityQueue** provides an ordered queue. The difference between **PriorityQueue** and **Collections**.*sort()*is that, **PriorityQueue** maintain an order queue at all time, but you can only get the head element from the queue. You can not randomly access its element like **PriorityQueue**.*get(4)*.
3. If there is no duplication in the collection, **TreeSet** is another choice. Same as **PriorityQueue**, it maintains the ordered set at all time. You can get the *lowest* and *highest* elements from the **TreeSet**. But you still cannot randomly access its element.

In a short, **Collections**.*sort()* provides a one-time ordered list. **PriorityQueue** and **TreeSet** maintain ordered collections at all time, in the cost of no indexed access of elements.

## 23. **Collections.emptyList() vs new instance**

The same question applies to *emptyMap()* and *emptySet()*.

Both methods return an empty list, but **Collections**.*emptyList()* returns a list that is immutable. This mean you cannot add new elements to the "**empty**" list. At the background, each call of **Collections**.*emptyList()* actually won't create a new instance of an empty list. Instead, it will reuse the existing empty instance. If you are familiar *Singleton* in the design pattern, you should know what I mean. So this will give you better performance if called frequently.

## 24. **Collections.copy**

There are two ways to copy a source list to a destination list. One way is to use **ArrayList** constructor

```java
ArrayList<Integer> dstList = new ArrayList<Integer>(srcList);
```

The other is to use **Collections**.*copy()* (as below). Note the first line, we allocate a list at least as long as the source list, because in the javadoc of **Collections**, it says **The destination list must be at least as long as the source list.**

```java
ArrayList<Integer> dstList = new ArrayList<Integer>(srcList.size());
Collections.copy(dstList, srcList);
```

Both methods are **shallow** copy. So what is the **difference** between these two methods?

- First, **Collections**.*copy()* won't reallocate the capacity of **dstList** even if **dstList** does not have enough space to contain all **srcList** elements. Instead, it will throw an **IndexOutOfBoundsException**. One may question if there is any benefit of it. One reason is that it guarantees the method runs in linear time. Also it makes suitable when you would like to reuse arrays rather than allocate new memory in the constructor of **ArrayList**.
- **Collections**.*copy()* can only accept **List** as both source and destination, while **ArrayList** accepts **Collection** as the parameter, therefore more general.

## 25. [Frequently Used Methods of Java HashMap](https://www.programcreek.com/2013/04/frequently-used-methods-of-java-hashmap/)

HashMap is very useful when a counter is required.

```java
HashMap<String, Integer> countMap = new HashMap<String, Integer>();
 
//.... a lot of a's like the following
if(countMap.keySet().contains(a)){
	countMap.put(a, countMap.get(a)+1);
}else{
	countMap.put(a, 1);
}
```

**1. Loop Through HashMap**

```java
Iterator it = mp.entrySet().iterator();
while (it.hasNext()) {
    Map.Entry pairs = (Map.Entry)it.next();
    System.out.println(pairs.getKey() + " = " + pairs.getValue());
}
```

```java
Map<Integer, Integer> map = new HashMap<Integer, Integer>();
for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
    System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
}
```

**2. Print HashMap**

```java
public static void printMap(Map mp) {
    Iterator it = mp.entrySet().iterator();
    while (it.hasNext()) {
        Map.Entry pairs = (Map.Entry)it.next();
        System.out.println(pairs.getKey() + " = " + pairs.getValue());
        it.remove(); // avoids a ConcurrentModificationException
    }
}
```

**3. Sort HashMap by Value**

The following code example take advantage of a constructor of TreeMap here.

```java
class ValueComparator implements Comparator<String> {
 
    Map<String, Integer> base;
 
    public ValueComparator(Map<String, Integer> base) {
        this.base = base;
    }
 
    public int compare(String a, String b) {
        if (base.get(a) >= base.get(b)) {
            return -1;
        } else {
            return 1;
        } // returning 0 would merge keys
    }
}
```

```java
HashMap<String, Integer> countMap = new HashMap<String, Integer>();
//add a lot of entries
countMap.put("a", 10);
countMap.put("b", 20);
 
ValueComparator vc =  new ValueComparator(countMap);
TreeMap<String,Integer> sortedMap = new TreeMap<String,Integer>(vc);
 
sortedMap.putAll(countMap);  
 
printMap(sortedMap);
```

## 26. [How to Convert Array to ArrayList in Java?](https://www.programcreek.com/2013/04/how-to-convert-array-to-arraylist-in-java/)

This article analyzes answers for a top-voted questions on Stack Overflow. The person who asked this question got a lot of reputation points, which could grant him permissions to do a lot of things on Stack Overflow. This does not make sense to me, but let's take a look at the question first.

The question is "how to convert the following array to an ArrayList?".

```java
Element[] array = {new Element(1),new Element(2),new Element(3)};
```

### 1. **Most popular and accepted answer**

The most popular and the accepted answer is the following:

```java
ArrayList<Element> arrayList = new ArrayList<Element>(Arrays.asList(array));
```

First, let's take a look at the Java Doc for the constructor method of ArrayList.

> ArrayList(Collection < ? extends E > c) : Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.

So what the constructor does is the following:

1. Convert the collection c to an array
2. Copy the array to ArrayList's own back array called "elementData"

Here is the source code of Contructor of ArrayList.

```java
public ArrayList(Collection<? extends E> c) {
       elementData = c.toArray();
       size = elementData.length;
 
       if (elementData.getClass() != Object[].class)
             elementData = Arrays.copyOf(elementData, size, Object[].class);
}
```

### **2. Next popular answer**

```java
List<Element> list = Arrays.asList(array);
```

It is not the best, because the size of the list returned from `asList()` is fixed. Actually the list returned is not `java.util.ArrayList`, but a private static class defined inside `java.util.Arrays`. We know `ArrayList` is essentially implemented as an array, and the list returned from `asList()` is a fixed-size list backed by the original array. In this way, if add or remove elements from the returned list, an UnsupportedOperationException will be thrown.

```java
list.add(new Element(4));
```

```java
Exception in thread "main" java.lang.ClassCastException: java.util.Arrays$ArrayList cannot be cast to java.util.ArrayList
	at collection.ConvertArray.main(ConvertArray.java:22)
```

### **3. Another Solution**

This solution is from Otto's comment below.

```java
Element[] array = {new Element(1), new Element(2)};
List<element> list = new ArrayList<element>(array.length);
Collections.addAll(list, array);
```

### **4. Indications of the question**

The problem is not hard, but interesting. Every Java programmer knows ArrayList, but it's easy to make such a mistake. I guess that is why this question is so popular. If a similar question asked about a Java library in a specific domain, it would be less likely to become so popular.

There are several answers that provide the same solution. This is also true for a lot of other questions on Stack Overflow, I guess people just don't care what others say if they would like to answer a question!

## 27. [Java – Sort Map By Value](https://www.programcreek.com/2013/03/java-sort-map-by-value/)

In Java, we can use the `TreeMap` class to sort a map by its keys. This class is very handy to use. However, sometimes we need to sort a map by its values. How to sort a map by its values is a most frequently asked question by Java programmers. In this post, I will develop the best way to write such a method.

### **1. Naive Method**

The following is a solution to sort a map of <String, Integer> pairs. This is often used in counting frequency of words.

```java
import java.util.Comparator;
import java.util.HashMap;
import java.util.TreeMap;
 
public class SortMapByValue {
 
	public static void main(String[] args) {
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put("a", 10);
		map.put("b", 30);
		map.put("c", 50);
		map.put("d", 40);
		map.put("e", 20);
		System.out.println(map);
 
		TreeMap<String, Integer> sortedMap = sortMapByValue(map);  
		System.out.println(sortedMap);
	}
 
	public static TreeMap<String, Integer> sortMapByValue(HashMap<String, Integer> map){
		Comparator<String> comparator = new ValueComparator(map);
		//TreeMap is a map sorted by its keys. 
		//The comparator is used to sort the TreeMap by keys. 
		TreeMap<String, Integer> result = new TreeMap<String, Integer>(comparator);
		result.putAll(map);
		return result;
	}
}

// a comparator that compares Strings
class ValueComparator implements Comparator<String>{
 
	HashMap<String, Integer> map = new HashMap<String, Integer>();
 
	public ValueComparator(HashMap<String, Integer> map){
		this.map.putAll(map);
	}
 
	@Override
	public int compare(String s1, String s2) {
		if(map.get(s1) >= map.get(s2)){
			return -1;
		}else{
			return 1;
		}	
	}
}
```

In this solution, we use a TreeMap to sort the map. When creating the TreeMap, we give it a comparator. The comparator accepts strings and compare the assocated values of the given string key in the map.

The method works well, but it only works for sorting String and Integer pairs. If we want to sort a map with other types of keys and values, it needs to be rewritten. Therefore, a more general solution is preferred.

### **2. More General Solution**

We can ignore the generic type and make the methods work for any types like the following.

```java
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
 
public class Solution {
	public static void main(String[] args) {
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put("a", 10);
		map.put("b", 30);
		map.put("c", 50);
		map.put("d", 40);
		map.put("e", 20);
		System.out.println(map);
 
		Map sortedMap = sortByValue(map);
		System.out.println(sortedMap);
	}
 
	public static Map sortByValue(Map unsortedMap) {
		Map sortedMap = new TreeMap(new ValueComparator(unsortedMap));
		sortedMap.putAll(unsortedMap);
		return sortedMap;
	}
 
}
 
class ValueComparator implements Comparator {
	Map map;
 
	public ValueComparator(Map map) {
		this.map = map;
	}
 
	public int compare(Object keyA, Object keyB) {
		Comparable valueA = (Comparable) map.get(keyA);
		Comparable valueB = (Comparable) map.get(keyB);
		return valueB.compareTo(valueA);
	}
}
```

The solution is not type-safe, we need a type-safe and general solution.

### **3. Using Generic Types**

```java
public class SortMapByValue {
 
	public static void main(String[] args) {
		// <String, Integer> Map
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put("a", 10);
		map.put("b", 30);
		map.put("c", 50);
		map.put("d", 40);
		map.put("e", 20);
		System.out.println(map);
 
 
		Comparator<String> comparator = new ValueComparator<String, Integer>(map);
		TreeMap<String, Integer> result = new TreeMap<String, Integer>(comparator);
		result.putAll(map);
 
		System.out.println(result);
 
		// <Integer, Integer> Map
 
		HashMap<Integer, Integer> map2 = new HashMap<Integer, Integer>();
		map2.put(1, 10);
		map2.put(2, 30);
		map2.put(3, 50);
		map2.put(4, 40);
		map2.put(5, 20);
		System.out.println(map2);
 
		Comparator<Integer> comparator2 = new ValueComparator<Integer, Integer>(map2);
		TreeMap<Integer, Integer> result2 = new TreeMap<Integer, Integer>(comparator2);
		result2.putAll(map2);
 
		System.out.println(result2);
 
	}
 
  
  // a comparator using generic type
class ValueComparator<K, V extends Comparable<V>> implements Comparator<K>{
 
	HashMap<K, V> map = new HashMap<K, V>();
 
	public ValueComparator(HashMap<K, V> map){
		this.map.putAll(map);
	}
 
	@Override
	public int compare(K s1, K s2) {
		return -map.get(s1).compareTo(map.get(s2));//descending order	
	}
}
```

### **4. Another Way of Using Generic Types**

```java
public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
	List<Map.Entry<K, V>> list = new LinkedList<>(map.entrySet());
	Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
		@Override
		public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
			return (e1.getValue()).compareTo(e2.getValue());
		}
	});
 
	Map<K, V> result = new LinkedHashMap<>();
	for (Map.Entry<K, V> entry : list) {
		result.put(entry.getKey(), entry.getValue());
	}
 
	return result;
}
```

## 28. [HashMap vs. TreeMap vs. Hashtable vs. LinkedHashMap](https://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/)

Map is one of the most important data structures in Java. In this post, I will illustrate how to use different types of maps, such as HashMap, TreeMap, HashTable and LinkedHashMap.

### **1. Map Overview**

![](https://www.programcreek.com/wp-content/uploads/2009/02/MapClassHierarchy-600x354.jpg)

There are 4 commonly used implementations of Map in Java SE - HashMap, TreeMap, Hashtable and LinkedHashMap. If we use only one sentence to describe each implementation, it would be the following:

- HashMap is implemented as a hash table, and there is no ordering on keys or values.

- TreeMap is implemented based on red-black tree structure, and it is ordered by the key.

- LinkedHashMap preserves the insertion order

- Hashtable is synchronized, in contrast to HashMap. It has an overhead for synchronization.

- This is the reason that HashMap should be used if the program is thread-safe.

### **2. HashMap**

If the key of a HashMap is a self-defined object, then the equals() and hashCode() contract need to be followed.

```java
class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}
	public String toString(){	
		return color + " dog";
	}
}
 
public class TestHashMap {
	public static void main(String[] args) {
		HashMap<Dog, Integer> hashMap = new HashMap<Dog, Integer>();
		Dog d1 = new Dog("red");
		Dog d2 = new Dog("black");
		Dog d3 = new Dog("white");
		Dog d4 = new Dog("white");
 
		hashMap.put(d1, 10);
		hashMap.put(d2, 15);
		hashMap.put(d3, 5);
		hashMap.put(d4, 20);
 
		//print size
		System.out.println(hashMap.size());
 
		//loop HashMap
		for (Entry<Dog, Integer> entry : hashMap.entrySet()) {
			System.out.println(entry.getKey().toString() + " - " + entry.getValue());
		}
	}
}
```

```
4
white dog - 5
black dog - 15
red dog - 10
white dog - 20
```

```java
class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}
 
	public boolean equals(Object o) {
		return ((Dog) o).color.equals(this.color);
	}
 
	public int hashCode() {
		return color.length();
	}
 
	public String toString(){	
		return color + " dog";
	}
}
```

```
3
red dog - 10
white dog - 20
black dog - 15
```

The reason is that HashMap doesn't allow two identical elements. By default, the hashCode() and equals() methods implemented in the Object class are used. The default hashCode() method gives distinct integers for distinct objects, and the equals() method only returns true when two references refer to the same object. Check out [the hashCode() and equals() contract](https://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/) if this is not obvious to you.

Check out the [most frequently used methods for HashMap](https://www.programcreek.com/2013/04/frequently-used-methods-of-java-hashmap/), such as iteration, print, etc.

### **3. TreeMap**

A TreeMap is sorted by keys. Let's first take a look at the following example to understand the "sorted by keys" idea.

```java
class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}
	public boolean equals(Object o) {
		return ((Dog) o).color.equals(this.color);
	}
 
	public int hashCode() {
		return color.length();
	}
	public String toString(){	
		return color + " dog";
	}
}
 
public class TestTreeMap {
	public static void main(String[] args) {
		Dog d1 = new Dog("red");
		Dog d2 = new Dog("black");
		Dog d3 = new Dog("white");
		Dog d4 = new Dog("white");
 
		TreeMap<Dog, Integer> treeMap = new TreeMap<Dog, Integer>();
		treeMap.put(d1, 10);
		treeMap.put(d2, 15);
		treeMap.put(d3, 5);
		treeMap.put(d4, 20);
 
		for (Entry<Dog, Integer> entry : treeMap.entrySet()) {
			System.out.println(entry.getKey() + " - " + entry.getValue());
		}
	}
}
```

```
Exception in thread "main" java.lang.ClassCastException: collection.Dog cannot be cast to java.lang.Comparable
	at java.util.TreeMap.put(Unknown Source)
	at collection.TestHashMap.main(TestHashMap.java:35)
```

Since TreeMaps are sorted by keys, the object for key has to be able to compare with each other, that's why it has to implement Comparable interface. For example, you use String as key, because String implements Comparable interface.

Let's change the Dog, and make it comparable.

```java
class Dog implements Comparable<Dog>{
	String color;
	int size;
 
	Dog(String c, int s) {
		color = c;
		size = s;
	}
 
	public String toString(){	
		return color + " dog";
	}
 
	@Override
	public int compareTo(Dog o) {
		return  o.size - this.size;
	}
}
 
public class TestTreeMap {
	public static void main(String[] args) {
		Dog d1 = new Dog("red", 30);
		Dog d2 = new Dog("black", 20);
		Dog d3 = new Dog("white", 10);
		Dog d4 = new Dog("white", 10);
 
		TreeMap<Dog, Integer> treeMap = new TreeMap<Dog, Integer>();
		treeMap.put(d1, 10);
		treeMap.put(d2, 15);
		treeMap.put(d3, 5);
		treeMap.put(d4, 20);
 
		for (Entry<Dog, Integer> entry : treeMap.entrySet()) {
			System.out.println(entry.getKey() + " - " + entry.getValue());
		}
	}
}
```

```
red dog - 10
black dog - 15
white dog - 20
```

It is sorted by key, i.e., dog size in this case.

If "Dog d4 = new Dog("white", 10);" is replaced with "Dog d4 = new Dog("white", 40);", the output would be:

```
white dog - 20
red dog - 10
black dog - 15
white dog - 5
```

The reason is that TreeMap now uses compareTo() method to compare keys. Different sizes make different dogs!

### **4. Hashtable**

From Java Doc:
The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.

### **5. LinkedHashMap**

LinkedHashMap is a subclass of HashMap. That means it inherits the features of HashMap. In addition, the linked list preserves the insertion-order.

Let's replace the HashMap with LinkedHashMap using the same code used for HashMap.

```java
class Dog {
	String color;
 
	Dog(String c) {
		color = c;
	}
 
	public boolean equals(Object o) {
		return ((Dog) o).color.equals(this.color);
	}
 
	public int hashCode() {
		return color.length();
	}
 
	public String toString(){	
		return color + " dog";
	}
}
 
public class TestHashMap {
	public static void main(String[] args) {
 
		Dog d1 = new Dog("red");
		Dog d2 = new Dog("black");
		Dog d3 = new Dog("white");
		Dog d4 = new Dog("white");
 
		LinkedHashMap<Dog, Integer> linkedHashMap = new LinkedHashMap<Dog, Integer>();
		linkedHashMap.put(d1, 10);
		linkedHashMap.put(d2, 15);
		linkedHashMap.put(d3, 5);
		linkedHashMap.put(d4, 20);
 
		for (Entry<Dog, Integer> entry : linkedHashMap.entrySet()) {
			System.out.println(entry.getKey() + " - " + entry.getValue());
		}		
	}
}
```

```
red dog - 10
black dog - 15
white dog - 20
```

The difference is that if we use HashMap the output could be the following - the insertion order is not preserved.

```
red dog - 10
white dog - 20
black dog - 15
```

## 29. [ArrayList vs. LinkedList vs. Vector](https://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/)

### **1. List Overview**

List, as its name indicates, is an ordered sequence of elements. When we talk about List, it is a good idea to compare it with Set which is a set of unique and unordered elements. The following is the class hierarchy diagram of Collection. From the hierarchy diagram you can get a general idea of Java Collections.

![](https://www.programcreek.com/wp-content/uploads/2009/02/java-collection-hierarchy.jpeg)

### **2. ArrayList vs. LinkedList vs. Vector**

From the hierarchy diagram, they all implement List interface. They are very similar to use. Their main difference is their implementation which causes different performance for different operations.

ArrayList is implemented as a resizable array. As more elements are added to ArrayList, its size is increased dynamically. It's elements can be accessed directly by using the get and set methods, since ArrayList is essentially an array.

LinkedList is implemented as a double linked list. Its performance on add and remove is better than Arraylist, but worse on get and set methods.

Vector is similar with ArrayList, but it is synchronized.

ArrayList is a better choice if your program is thread-safe. Vector and ArrayList require more space as more elements are added. Vector each time doubles its array size, while ArrayList grow 50% of its size each time. LinkedList, however, also implements Queue interface which adds more methods than ArrayList and Vector, such as offer(), peek(), poll(), etc.

Note: The default initial capacity of an ArrayList is pretty small. It is a good habit to construct the ArrayList with a higher initial capacity. This can avoid the resizing cost.

### **3. ArrayList example**

```java
ArrayList<Integer> al = new ArrayList<Integer>();
al.add(3);
al.add(2);		
al.add(1);
al.add(4);
al.add(5);
al.add(6);
al.add(6);
 
Iterator<Integer> iter1 = al.iterator();
while(iter1.hasNext()){
	System.out.println(iter1.next());
}
```

### **4. LinkedList example**

```java
LinkedList<Integer> ll = new LinkedList<Integer>();
ll.add(3);
ll.add(2);		
ll.add(1);
ll.add(4);
ll.add(5);
ll.add(6);
ll.add(6);
 
Iterator<Integer> iter2 = ll.iterator();
while(iter2.hasNext()){
	System.out.println(iter2.next());
}
```

As shown in the examples above, they are similar to use. The real difference is their underlying implementation and their operation complexity.

### **5. Vector**

Vector is almost identical to ArrayList, and the difference is that Vector is synchronized. Because of this, it has an overhead than ArrayList. Normally, most Java programmers use ArrayList instead of Vector because they can synchronize explicitly by themselves.

### **6. Performance of ArrayList vs. LinkedList**



![](https://www.programcreek.com/wp-content/uploads/2013/03/arraylist-vs-linkedlist1.png)

![](https://www.programcreek.com/wp-content/uploads/2013/03/arraylist-vs-linkedlist-complexity.png)



## 30. [HashSet vs. TreeSet vs. LinkedHashSet](https://www.programcreek.com/2013/03/hashset-vs-treeset-vs-linkedhashset/)

A Set contains no duplicate elements. That is one of the major reasons to use a set. There are 3 commonly used implementations of Set: HashSet, TreeSet and LinkedHashSet. When and which to use is an important question. In brief, if you need a fast set, you should use HashSet; if you need a sorted set, then TreeSet should be used; if you need a set that can be store the insertion order, LinkedHashSet should be used.

### **1. Set Interface**

Set interface extends Collection interface. In a set, no duplicates are allowed. Every element in a set must be unique. You can simply add elements to a set, and duplicates will be removed automatically.

![](https://www.programcreek.com/wp-content/uploads/2009/02/java-collection-hierarchy.jpeg)

### **2. HashSet vs. TreeSet vs. LinkedHashSet**

HashSet is Implemented using a hash table. Elements are not ordered. The add, remove, and contains methods have constant time complexity O(1).

TreeSet is implemented using a tree structure(red-black tree in algorithm book). The elements in a set are sorted, but the add, remove, and contains methods has time complexity of O(log (n)). It offers several methods to deal with the ordered set like first(), last(), headSet(), tailSet(), etc.

LinkedHashSet is between HashSet and TreeSet. It is implemented as a hash table with a linked list running through it, so it provides the order of insertion. The time complexity of basic methods is O(1).

### **3. TreeSet Example**

```java
TreeSet<Integer> tree = new TreeSet<Integer>();
tree.add(12);
tree.add(63);
tree.add(34);
tree.add(45);
 
Iterator<Integer> iterator = tree.iterator();
System.out.print("Tree set data: ");
while (iterator.hasNext()) {
    System.out.print(iterator.next() + " ");
}
```

Output is sorted as follows:

```
Tree set data: 12 34 45 63 
```

Now let's define a Dog class as follows:

```java
class Dog {
	int size;
 
	public Dog(int s) {
		size = s;
	}
 
	public String toString() {
		return size + "";
	}
}
```

Let's add some dogs to TreeSet like the following:

```java
import java.util.Iterator;
import java.util.TreeSet;
 
public class TestTreeSet {
	public static void main(String[] args) {
		TreeSet<Dog> dset = new TreeSet<Dog>();
		dset.add(new Dog(2));
		dset.add(new Dog(1));
		dset.add(new Dog(3));
 
		Iterator<Dog> iterator = dset.iterator();
 
		while (iterator.hasNext()) {
			System.out.print(iterator.next() + " ");
		}
	}
}
```

Compile ok, but run-time error occurs:

```

```

```
Exception in thread "main" java.lang.ClassCastException: collection.Dog cannot be cast to java.lang.Comparable
	at java.util.TreeMap.put(Unknown Source)
	at java.util.TreeSet.add(Unknown Source)
	at collection.TestTreeSet.main(TestTreeSet.java:22)
```

### **4. HashSet Example**

```java
HashSet<Dog> dset = new HashSet<Dog>();
dset.add(new Dog(2));
dset.add(new Dog(1));
dset.add(new Dog(3));
dset.add(new Dog(5));
dset.add(new Dog(4));
Iterator<Dog> iterator = dset.iterator();
while (iterator.hasNext()) {
	System.out.print(iterator.next() + " ");
}
```

Output:

```
5 3 2 1 4 
```

Note the order is not certain.

### **5. LinkedHashSet Example**

```java
LinkedHashSet<Dog> dset = new LinkedHashSet<Dog>();
dset.add(new Dog(2));
dset.add(new Dog(1));
dset.add(new Dog(3));
dset.add(new Dog(5));
dset.add(new Dog(4));
Iterator<Dog> iterator = dset.iterator();
while (iterator.hasNext()) {
	System.out.print(iterator.next() + " ");
}
```

The order of the output is certain and it is the insertion order:

```
2 1 3 5 4 
```

### **6. Performance testing**

add()

![](https://www.programcreek.com/wp-content/uploads/2013/03/hashset-treeset-linkedhashset1.png)

## 31. [Sort LinkedList of User-Defined Objects in Java](https://www.programcreek.com/2013/01/sort-linkedlist-of-user-defined-objects-in-java/)

For sorting a list in Java, you can use `sort(List<T> list) `method. This method can sort a list in which all elements must implement the Comparable interface.

In the example below, the House class is user-defined. To make it comparable, it implements the Comparable interface. By using the

```
sort(List<T> list) 
```

method, it can be sorted in ascending order.

If you want to reverse the sorting order, you can simple use `sort(List<T> list, Comparator<? super T> c) `. The parameter is Collections.reverseOrder() method. This method returns a Comparator that use the reverse of the natural ordering on a collection of objects that implement the Comparable interface. Since the House class implement Comparable interface, we can use this method to reverse order automatically.

```java
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
 
//sort self-defined object linkedlist in Java
 
class House implements Comparable<House> {
	String type;
	int size;
 
	public House(String t, int s) {
		type = t; 
		size = s;
	}
 
	@Override
	public int compareTo(House o) {
		int comparedSize = o.size;
		if (this.size > comparedSize) {
			return 1;
		} else if (this.size == comparedSize) {
			return 0;
		} else {
			return -1;
		}
	}
 
	public String toString() {
		return type;
	}
}
 
public class SortLinkedList {
	public static void main(String[] args) {
		LinkedList<House> houseList = new LinkedList<House>();
		houseList.add(new House("medium", 200));
		houseList.add(new House("small", 100));
		houseList.add(new House("large", 300));
		System.out.println(houseList);
 
		// sort in ascending order
		Collections.sort(houseList);
		System.out.println(houseList);
 
		// sort in descending order
		Collections.sort(houseList, Collections.reverseOrder());
		System.out.println(houseList);
	}
 
	public static void printList(List l) {
		for (Object o : l) {
			System.out.println(o);
		}
	}
}
```

## 32. [Loop an Iterable in Java](https://www.programcreek.com/2012/10/loop-a-iterable-in-java/)

If you use some Java API and it returns an Iterable, such as `Iterable`, you may want to loop this iterable.

The method is pretty simple as follows:

```java
Iterable<String> result = ... //result returned from some method.
for(String s: result){
	System.out.println(s);
}
```

## 33. [Sort a String LinkedList in Java](https://www.programcreek.com/2012/09/sort-a-string-linkedlist-in-java/)

Sorting a string LinkedList in Java is easy. You can sort the string LinkedList in ascending alphabetical order by using `sort(List<T> list) `. You can also sort the string LinkedList in descending alphabetical order by using `sort(List<T> list, Comparator<? super T> c) `.

Here is the code:

```java
public static void main(String[] args) {
	LinkedList<String> stringList = new LinkedList<String>();
	stringList.add("a");
	stringList.add("c");
	stringList.add("b");
	System.out.println(stringList);
 
	//sort in ascending order
	Collections.sort(stringList);
	System.out.println(stringList);
 
	//sort in descending order
	Collections.sort(stringList, Collections.reverseOrder());
	System.out.println(stringList);	
}
```

## 34. [Sort a Double LinkedList in Java](https://www.programcreek.com/2011/09/sort-a-double-linkedlist-in-java/)

This code is for showing how to sort a Double LinkedList in Java. You can use `sort(List<T> list)`method. It will sort the double list in ascending order. If you want to sort it in descending order, you can use `sort(List<T> list, Comparator<? super T> c) `.

```java
public static void main(String[] args) {
	LinkedList<Double> doubleList = new LinkedList<Double>();
	doubleList.add(2.2);
	doubleList.add(1.1);
	doubleList.add(3.3);
	System.out.println(doubleList);
 
	//sort in ascending order
	Collections.sort(doubleList);
	System.out.println(doubleList);
 
	//sort in descending order
	Collections.sort(doubleList, Collections.reverseOrder());
	System.out.println(doubleList);	
}
```

## 35. [Use Java Set to get a collection of unique data](https://www.programcreek.com/2010/11/use-java-set-to-get-a-collection-of-unique-data/)

To keep the unique value of a large data set, Set would be a good option. Every element in a set is unique, when a duplicate element is added, it is ignored.

Here is a sample code from

```java
public class FindDups2 {
    public static void main(String[] args) {
        Set<String> uniques = new HashSet<String>();
        Set<String> dups    = new HashSet<String>();
 
        for (String a : args)
            if (!uniques.add(a))
                dups.add(a);
 
	// Destructive set-difference
        uniques.removeAll(dups);
 
        System.out.println("Unique words:    " + uniques);
        System.out.println("Duplicate words: " + dups);
    }
}
```

## 36. [Collection Classes Summary Table](https://www.programcreek.com/2009/02/collection-interface-concrete-implementation-classes-summary-and-some-examples/)

![](https://www.programcreek.com/wp-content/uploads/2009/02/collection.bmp)

## 37. [The Interface and Class Hierarchy Diagram of Java Collections](https://www.programcreek.com/2009/02/the-interface-and-class-hierarchy-for-collections/)

### **1. Collection vs Collections**

First of all, "Collection" and "Collections" are two different concepts. As you will see from the hierarchy diagram below, "Collection" is a root interface in the Collection hierarchy but "Collections" is a class which provide static methods to manipulate on some Collection types.

![](https://www.programcreek.com/wp-content/uploads/2009/02/CollectionVsCollections.jpeg)

### **2. Class hierarchy of Collection**

The following diagram demonstrates class hierarchy of Collection.

![](https://www.programcreek.com/wp-content/uploads/2009/02/java-collection-hierarchy.jpeg)

### **3. Class hierarchy of Map**

Here is class hierarchy of Map.

![](https://www.programcreek.com/wp-content/uploads/2009/02/MapClassHierarchy-600x354.jpg)

### **4. Summary of classes**

![](https://www.programcreek.com/wp-content/uploads/2009/02/collection-summary.png)

## 38. Collections trump arrays

Developers new to Java technology may not know that arrays were originally included in the language to head-off performance criticism from C++ developers back in the early 1990s. Well, we've come a long way since then, and the array's performance advantages generally come up short when weighed against those of the Java Collections libraries.

Dumping array contents into a string, for example, requires iterating through the array and concatenating the contents together into a `String`; whereas, the Collections implementations all have a viable `toString()` implementation.

Except for rare cases, it's good practice to convert any array that comes your way to a collection as quickly as possible. Which then begs the question, what's the easiest way to make the switch? As it turns out, the Java Collections API makes it easy, as shown in Listing 1:

##### Listing 1. ArrayToList

```java
import java.util.*;
 
public class ArrayToList
{
    public static void main(String[] args)
    {
        // This gives us nothing good
        System.out.println(args);
         
        // Convert args to a List of String
        List<String> argList = Arrays.asList(args);
         
        // Print them out
        System.out.println(argList);
    }
}
```

Note that the returned `List` is unmodifiable, so attempts to add new elements to it will throw an `UnsupportedOperationException`.

And, because `Arrays.asList()` uses a *varargs* parameter for elements to add into the `List`, you can also use it to easily create `List`s out of `new`ed objects.

## 39. Iterating is inefficient

It's not uncommon to want to move the contents of one collection (particularly one that was manufactured out of an array) over into another collection or to remove a small collection of objects from a larger one.

You might be tempted to simply iterate through the collection and add or remove each element as it's found, but don't.

Iterating, in this case, has major disadvantages:

- It would be inefficient to resize the collection with each add or remove.
- There's a potential concurrency nightmare in acquiring a lock, doing the operation, and releasing the lock each time.
- There's the race condition caused by other threads banging on your collection while the add or remove is taking place.

You can avoid all of these problems by using `addAll` or `removeAll` to pass in the collection containing the elements you want to add or remove.

## 40. For loop through any Iterable

The enhanced for loop, one of the great conveniences added to the Java language in Java 5, removed the last barrier to working with Java Collections.

Before, developers had to manually obtain an `Iterator`, use `next()` to obtain the object pointed to from the `Iterator`, and check to see if more objects were available via `hasNext()`. Post Java 5, we're free to use a for-loop variant that handles all of the above silently.

Actually, this enhancement works with *any object* that implements the `Iterable`interface, not just `Collections`.

Listing 2 shows one approach to making a list of children from a `Person` object available as an `Iterator`. Rather than handing out a reference to the internal `List` (which would enable callers outside the `Person` to add kids to your family — something most parents would find uncool), the `Person` type implements `Iterable`. This approach also enables the enhanced for loop to walk through the children.

```java
// Person.java
import java.util.*;
 
public class Person
    implements Iterable<Person>
{
    public Person(String fn, String ln, int a, Person... kids)
    {
        this.firstName = fn; this.lastName = ln; this.age = a;
        for (Person child : kids)
            children.add(child);
    }
    public String getFirstName() { return this.firstName; }
    public String getLastName() { return this.lastName; }
    public int getAge() { return this.age; }
     
    public Iterator<Person> iterator() { return children.iterator(); }
     
    public void setFirstName(String value) { this.firstName = value; }
    public void setLastName(String value) { this.lastName = value; }
    public void setAge(int value) { this.age = value; }
     
    public String toString() { 
        return "[Person: " +
            "firstName=" + firstName + " " +
            "lastName=" + lastName + " " +
            "age=" + age + "]";
    }
     
    private String firstName;
    private String lastName;
    private int age;
    private List<Person> children = new ArrayList<Person>();
}
 
// App.java
public class App
{
    public static void main(String[] args)
    {
        Person ted = new Person("Ted", "Neward", 39,
            new Person("Michael", "Neward", 16),
            new Person("Matthew", "Neward", 10));
 
        // Iterate over the kids
        for (Person kid : ted)
        {
            System.out.println(kid.getFirstName());
        }
    }
}
```

## 41. Classic and custom algorithms

Have you ever wanted to walk a `Collection`, but in reverse? That's where a classic Java Collections algorithm comes in handy.

```java
public class ReverseIterator
{
    public static void main(String[] args)
    {
        Person ted = new Person("Ted", "Neward", 39,
            new Person("Michael", "Neward", 16),
            new Person("Matthew", "Neward", 10));
 
        // Make a copy of the List
        List<Person> kids = new ArrayList<Person>(ted.getChildren());
        // Reverse it
        Collections.reverse(kids);
        // Display it
        System.out.println(kids);
    }
}
```

## 42. Lists aren't the same as arrays

Java developers frequently make the mistake of assuming that `ArrayList` is simply a replacement for the Java array. Collections are backed by arrays, which leads to good performance when looking up items randomly within a collection. And, like arrays, collections use integer-ordinals to obtain particular items. Still, a collection isn't a drop-in replacement for an array.

The trick to differentiating collections from arrays is knowing the difference between *order* and *position*. For example, `List` is an interface that preserves the *order* in which items are placed into a collection, as Listing 1 shows:

```java
import java.util.*;
 
public class OrderAndPosition
{
    public static <T> void dumpArray(T[] array)
    {
        System.out.println("=============");
        for (int i=0; i<array.length; i++)
            System.out.println("Position " + i + ": " + array[i]);
    }
    public static <T> void dumpList(List<T> list)
    {
        System.out.println("=============");
        for (int i=0; i<list.size(); i++)
            System.out.println("Ordinal " + i + ": " + list.get(i));
    }
     
    public static void main(String[] args)
    {
        List<String> argList = new ArrayList<String>(Arrays.asList(args));
 
        dumpArray(args);
        args[1] = null;
        dumpArray(args);
         
        dumpList(argList);
        argList.remove(1);
        dumpList(argList);
    }
}
```

When the third element is removed from the above `List`, the other items "behind" it slide up to fill the empty slots. Clearly, this collections behavior differs from that of an array. (In fact, removing an item from an array is itself not quite the same thing as removing it from a `List`— "removing" an item from an array means overwriting its index slot with a new reference or null.)

## 43. `Iterator`, you surprise me!

There's no doubt that Java developers love the Java Collections `Iterator`, but when was the last time you really looked at the `Iterator` interface? Most of the time, we just slap `Iterator` inside a `for()` loop or enhanced `for()` loop and move on, so to speak.

But, for those who go digging, `Iterator` has two surprises in store.

First, `Iterator` supports the ability to remove an object from a source collection safely, by calling `remove()` on the `Iterator` itself. The point here is to avoid a `ConcurrentModifiedException`, which signals precisely what its name implies: that a collection was modified while an `Iterator`was open against it. Some collections will let you get away with removing or adding elements to a `Collection` while iterating across it, but calling `remove()` on the `Iterator` is a safer practice.

Second, `Iterator` supports a derived (and arguably more powerful) cousin. `ListIterator`, only available from `List`s, supports both adding and removing from a `List` during iteration, as well as bidirectional scrolling through `List`s.

## 44. Not all `Iterable`s come from collections

Ruby and Groovy developers like to brag about how they can iterate across a text file and print its contents to the console with a single line of code. Most of the time, they say, doing the same thing in Java programming takes dozens of lines of code: open a `FileReader`, then a `BufferedReader`, then create a `while()` loop to call `getLine()` until it comes back *null*. And, of course, you have to do all this in a `try/catch/finally` block that will handle exceptions and close the file handle when finished.

It may seem like a silly and pedantic argument, but it does have some merit.

What they (and quite a few Java developers) don't know is that not all `Iterable`s have to come from collections. Instead, an `Iterable` can create an `Iterator` that knows how to manufacture the next element out of thin air, rather than blindly handing it back from a pre-existing `Collection`:

```java
// FileUtils.java
import java.io.*;
import java.util.*;
 
public class FileUtils
{
    public static Iterable<String> readlines(String filename)
        throws IOException
    {
        final FileReader fr = new FileReader(filename);
        final BufferedReader br = new BufferedReader(fr);
         
        return new Iterable<String>() {
            public <code>Iterator</code><String> iterator() {
                return new <code>Iterator</code><String>() {
                    public boolean hasNext() {
                        return line != null;
                    }
                    public String next() {
                        String retval = line;
                        line = getLine();
                        return retval;
                    }
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                    String getLine() {
                        String line = null;
                        try {
                            line = br.readLine();
                        }
                        catch (IOException ioEx) {
                            line = null;
                        }
                        return line;
                    }
                    String line = getLine();
                };
            }   
        };
    }
}
 
//DumpApp.java
import java.util.*;
 
public class DumpApp
{
    public static void main(String[] args)
        throws Exception
    {
        for (String line : FileUtils.readlines(args[0]))
            System.out.println(line);
    }
}
```

## 45. Beware the mutable `hashCode()`

`Map` is a wonderful collection, bringing us the niftiness of key/value pair collections often found in other languages like Perl. And the JDK gives us a great `Map` implementation in the form of the `HashMap`, which uses hashtables internally to support fast key lookups for corresponding values. But therein lies a subtle problem: Keys that support hash codes dependent on the contents of mutable fields are vulnerable to a bug that will drive even the most patient Java developer batty.

Assuming the `Person` object in Listing 3 has a typical `hashCode()` (which uses the `firstName`, `lastName`, and `age` fields — all non-final — to calculate the `hashCode()`), the `get()` call to `Map` will fail and return `null`:

```java
// Person.java
import java.util.*;
 
public class Person
    implements Iterable<Person>
{
    public Person(String fn, String ln, int a, Person... kids)
    {
        this.firstName = fn; this.lastName = ln; this.age = a;
        for (Person kid : kids)
            children.add(kid);
    }
     
    // ...
     
    public void setFirstName(String value) { this.firstName = value; }
    public void setLastName(String value) { this.lastName = value; }
    public void setAge(int value) { this.age = value; }
     
    public int hashCode() {
        return firstName.hashCode() & lastName.hashCode() & age;
    }
 
    // ...
 
    private String firstName;
    private String lastName;
    private int age;
    private List<Person> children = new ArrayList<Person>();
}
 
 
// MissingHash.java
import java.util.*;
 
public class MissingHash
{
    public static void main(String[] args)
    {
        Person p1 = new Person("Ted", "Neward", 39);
        Person p2 = new Person("Charlotte", "Neward", 38);
        System.out.println(p1.hashCode());
         
        Map<Person, Person> map = new HashMap<Person, Person>();
        map.put(p1, p2);
         
        p1.setLastName("Finkelstein");
        System.out.println(p1.hashCode());
         
        System.out.println(map.get(p1));
    }
}
```

Clearly, this approach is a pain but the solution is easy: Never use a mutable object type as a key in a `HashMap`.

## 46. `equals()` vs `Comparable`

When cruising through the Javadocs, Java developers frequently happen across the `SortedSet` type (and its lone implementation in the JDK, the `TreeSet`). Because `SortedSet` is the only `Collection` in the `java.util` package that offers any sorting behavior, developers often begin using it without questioning the details too closely. Listing 4 demonstrates:

```java
import java.util.*;
 
public class UsingSortedSet
{
    public static void main(String[] args)
    {
        List<Person> persons = Arrays.asList(
            new Person("Ted", "Neward", 39),
            new Person("Ron", "Reynolds", 39),
            new Person("Charlotte", "Neward", 38),
            new Person("Matthew", "McCullough", 18)
        );
        SortedSet ss = new TreeSet(new Comparator<Person>() {
            public int compare(Person lhs, Person rhs) {
                return lhs.getLastName().compareTo(rhs.getLastName());
            }
        });
        ss.addAll(perons);
        System.out.println(ss);
    }
}
```

After working with this code for a while, you might discover one of the `Set`'s core features: that it disallows duplicates. This feature is actually described in the `Set`Javadoc. A `Set` is a "collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element."

But this doesn't actually seem to be the case — although none of the `Person`objects in [Listing 4](https://www.ibm.com/developerworks/java/library/j-5things3/index.html#listing4) are equal (according to the `equals()` implementation on`Person`), only three objects are present within the `TreeSet` when printed.

Contrary to the stated nature of the set, the `TreeSet`, which requires objects to either implement `Comparable` directly or have a `Comparator` passed in at the time of construction, doesn't use `equals()` to compare the objects; it uses the`compare` or `compareTo` methods of `Comparator/Comparable`.

So, objects stored in a `Set` will have two potential means of determining equality: the expected `equals()` method and the `Comparable/Comparator` method, depending on the context of who is asking.

What's worse, it isn't sufficient to simply declare that the two should be identical, because comparison for the purpose of sorting isn't the same as comparison for the purpose of equality: It may be perfectly acceptable to consider two `Person`s equal when sorting by last name, but not equal in terms of their contents.

Always ensure that the difference between `equals()` and the`Comparable.compareTo()`-returning-0 is clear when implementing `Set`. By extension, the difference should also be clear in your documentation.

## 47. **什么是Java集合API**

Java集合框架API是用来表示和操作集合的统一框架，它包含接口、实现类、以及帮助程序员完成一些编程的算法。简言之，API在上层完成以下几件事：

● 编程更加省力，提高城程序速度和代码质量

● 非关联的API提高互操作性

● 节省学习使用新API成本

● 节省设计新API的时间

● 鼓励、促进软件重用

具体来说，有6个集合接口，最基本的是Collection接口，由三个接口Set、List、SortedSet继承，另外两个接口是Map、SortedMap,这两个接口不继承Collection，表示映射而不是真正的集合。

## 48. 什么是Iterator

一些集合类提供了内容遍历的功能，通过java.util.Iterator接口。这些接口允许遍历对象的集合。依次操作每个元素对象。当使用Iterators时，在获得Iterator的时候包含一个集合快照。通常在遍历一个Iterator的时候不建议修改集合本省。

## 49. **Iterator与ListIterator有什么区别？**

Iterator:只能正向遍历集合，适用于获取移除元素。ListIerator：继承Iterator,可以双向列表的遍历，同样支持元素的修改。

## 50. **什么是HaspMap和Map？**

Map是接口，Java 集合框架中一部分，用于存储键值对，HashMap是用哈希算法实现Map的类。

## 51. **HashMap与HashTable有什么区别？对比Hashtable VS HashMap**

两者都是用key-value方式获取数据。Hashtable是原始集合类之一(也称作遗留类)。HashMap作为新集合框架的一部分在Java2的1.2版本中加入。它们之间有一下区别：

● HashMap和Hashtable大致是等同的，除了非同步和空值(HashMap允许null值作为key和value，而Hashtable不可以)。

● HashMap没法保证映射的顺序一直不变，但是作为HashMap的子类LinkedHashMap，如果想要预知的顺序迭代(默认按照插入顺序),你可以很轻易的置换为HashMap，如果使用Hashtable就没那么容易了。

● HashMap不是同步的，而Hashtable是同步的。

● 迭代HashMap采用快速失败机制，而Hashtable不是，所以这是设计的考虑点。

## 52.  在Hashtable上下文中同步是什么意思？

同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。

## 53. **什么叫做快速失败特性**

从高级别层次来说快速失败是一个系统或软件对于其故障做出的响应。一个快速失败系统设计用来即时报告可能会导致失败的任何故障情况，它通常用来停止正常的操作而不是尝试继续做可能有缺陷的工作。当有问题发生时，快速失败系统即时可见地发错错误告警。在Java中，快速失败与iterators有关。如果一个iterator在集合对象上创建了，其它线程欲“结构化”的修改该集合对象，并发修改异常 (ConcurrentModificationException) 抛出。

## 54. **怎样使Hashmap同步**

HashMap可以通过Map m = Collections.synchronizedMap（hashMap）来达到同步的效果。

## 55. **什么时候使用Hashtable，什么时候使用HashMap**

基本的不同点是Hashtable同步HashMap不是的，所以无论什么时候有多个线程访问相同实例的可能时，就应该使用Hashtable，反之使用HashMap。非线程安全的数据结构能带来更好的性能。

如果在将来有一种可能—你需要按顺序获得键值对的方案时，HashMap是一个很好的选择，因为有HashMap的一个子类LinkedHashMap。所以如果你想可预测的按顺序迭代(默认按插入的顺序)，你可以很方便用LinkedHashMap替换HashMap。反观要是使用的Hashtable就没那么简单了。同时如果有多个线程访问HashMap，Collections.synchronizedMap()可以代替，总的来说HashMap更灵活。

## 56. **为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector**

你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全(如果你迭代一个Vector,你还是要加锁，以避免其它线程在同一时刻改变集合).而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。

事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，oracle也从没宣称过要废弃Vector.

## 57. Collection和Collections的区别

```
这种问题属于集合框架送分题，一般问这种题的面试官要么是带你预热（好人啊！），要么就是不懂Java（比如腾讯的面试官）。Collection是集合类List和Set的父接口，规定了集合的通用方法，不同子类的具体实现略有不同。Collections是集合工具类，提供了一系列static方法辅助操作，常用的有排序sort()、转化为线程安全的synchronizedXXX()等。
```

## 58.最常见的数据结构有哪些，在哪些场景下应用它们？

**数组**是最常用的数据结构。数组的特点是长度固定，可以用下标索引，并且所有的元素的类型都是一致的。数组常用的场景有把：从数据库里读取雇员的信息存储为EmployeeDetail[]，把一个字符串转换并存储到一个字节数组中便于操作和处理，等等。尽量把数组封装在一个类里，防止数据被错误的操作弄乱。另外，这一点也适合其他的数据结构。

**列表**和数组很相似，只不过它的大小可以改变。列表一般都是通过一个固定大小的数组来实现的，并且会在需要的时候自动调整大小。列表里可以包含重复的元素。常用的场景有，添加一行新的项到订单列表里，把所有过期的商品移出商品列表，等等。一般会把列表初始化成一个合适的大小，以减少调整大小的次数。

**集合**和列表很相似，不过它不能放重复的元素。当你需要存储不同的元素时，你可以使用集合。

**队列**和堆栈有些相似，不同之处在于在队列里第一个插入的元素也是第一个被删除的元素（即是先进先出）。这种先进先出的结构是通过只提供peek()，offer()和poll()这几个方法来访问数据进行限制来达到的。例如，排队等待公交车，银行或者超市里的等待列队等等，都是可以用队列来表示。

**链表**是一种由多个节点组成的数据结构，并且每个节点包含有数据以及指向下一个节点的引用，在双向链表里，还会有一个指向前一个节点的引用。例如，可以用单向链表和双向链表来实现堆栈和队列，因为链表的两端都是可以进行插入和删除的动作的。当然，也会有在链表的中间频繁插入和删除节点的场景。Apache的类库里提供了一个TreeList的实现，它是链表的一个很好的替代，因为它只多占用了一点内存，但是性能比链表好很多。也就是说，从这点来看链表其实不是一个很好的选择。

ArrayList是列表的一个很好的实现。相比较TreeList而言，ArrayList在除了在列表中间插入或者删除元素的情况，其他操作都比TreeList快很多。TreeList的实现是在内部使用了一个树形的结构来保证所有的插入和删除动作的复杂度都是O(log n)的。这种实现方式使得TreeList在频繁插入和删除元素的时候的性能远远高于ArrayList和LinkedList。

**HashMap**的访问时间接近稳定，它是一种键值对映射的数据结构。这个数据结构是通过数组来实现的。它通过hash函数来给元素定位，并且用冲突检测算法来处理被hash到同一位置的值。例如，保存雇员的信息可以用雇员的id来作为key，对从properties文件里读入的属性-属性值可以用key/value对来保存，等等。HashMap在初始化的时候，给定一个合适的大小可以减少调整大小的次数。

**树**是一种由节点组成的数据结构，每个节点都包含数据元素，并且有一个或多个子节点，每个子节点指向一个父节点（译者注：除了根节点）可以表示层级关系或者数据元素的顺序关系。常用的场景有表示一个组织里的雇员层级关系，XML元素的层级关系，等等。如果树的每个子节点最多有两个叶子节点，那么这种树被称为二叉树。二叉树是一种非常常用的树形结构， 因为它的这种结构使得节点的插入和删除都非常高效。树的边表示从一个节点到另外一个节点的快捷路径

只要数据元素的关系可以表示成节点和边的网状结构的话，就可以用**图**来表示。树是一种特殊的图，它的所有节点都只能有一个父节点。和树不同的是，图的形状是由实际问题或者问题的抽象来决定的。例如，图中节点（或者顶点）可以表示不同的城市，而图的边则可以表示两个城市之间的航线。

## 59. HashMap和TreeMap在性能上有什么样的差别呢？你比较倾向于使用哪一个?

一个平衡树的性能是O(logn)。Java里的TreeMap用一个红黑树来保证key/value的排序。红黑树是平衡二叉树。保证二叉树的平衡性，使得插入，删除和查找都比较快，时间复杂度都是O(log n)。不过它没有HashMap快，HashMap的时间复杂度是O(1)，但是TreeMap的优点在于它里面键值是排过序的，这样就提供了一些其他的很有用的功能。

## 59.1 怎么去选择该使用哪一个呢？

使用无序的HashSet和HashMap，还是使用有序的TreeSet和TreeMap，主要取决于你的实际使用场景，一定程度上还和数据的大小以及运行环境有关。比较实际的一个原因是，如果插入和更新都比较频繁的话，那么保证元素的有序可以提高快速和频繁查找的性能。如果对于排序操作（例如产生一个报表合作者运行一个批处理程序）的要求不是很频繁的话，那么把数据以无序的方式存储，然后在需要排序的时候用Collections.sort(…)来进行排序，会比用有序的方式来存储可能会更加高效。这个只是一种可选的方式，没人能给你一个确切的答案。即使是复杂度的理论，例如O(n)，成立的前提也是在n足够大的情况下。只要在n足够小的情况下，就算是O(n)的算法也可能会比O（log n)的算法更加高效。另外，一个算法可能在AMD处理器上的速度比在Intel处理器上快。如果你的系统有交换区的话，那么你还要考虑磁盘的性能。唯一可以确定的性能测试途径是用大小合适的数据来测试和衡量程序的性能和内存使用量。在你所选择的硬件上来测试这两种指标，是最合适的方法。

## 60. 如何权衡是用无序的数组还是有序的数组呢？

有序数组最大的优点在于n比较大的时候，搜索元素所花的时间O(log n)比无序素组所需要的时间O(n)要少很多。有序数组的缺点在于插入的时间开销比较大（一般是O(n))，因为所有比插入元素大的值都要往后移动。而无序数组的插入时间开销是常量时间，也就是说，插入的速度和元素的数量无关。下面的代码片段展示了向有序数组和无序数组插入元素。

## 61. 怎么实现一个不可变集合？

这个功能在Collections类里实现了，它通过装饰模式实现了对一般集合的封装。

```java 
public class ReadOnlyExample {
    public static void main(String args[ ]) {
        Set<string> set = new HashSet<string>( );
        set.add("Java");
        set.add("JEE");
        set.add("Spring");
        set.add("Hibernate");
        set = Collections.unmodifiableSet(set);
        set.add("Ajax");                                           // not allowed.
  }
}
```

## 62. 下面的代码的功能是什么呢？其中的LinkedHashSet能用HashSet来取代吗？

```java
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
 
public class CollectionFunction {
    public <e> List<e> function (List <e> list) {
          return new ArrayList<e>(new LinkedHashSet<e>(list));
    }
}
```

上面的代码代码通过把原有列表传入一个LinkedHashSet来去除重复的元素。在这个情况里，LinkedHashSet可以保持元素原来的顺序。如果这个顺序是不需要的话，那么上面的LinkedHashSet可以用HashSet来替换。

